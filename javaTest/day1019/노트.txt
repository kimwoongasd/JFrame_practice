** 생성자에 대하여 아는대로 설명하시오**
- 기본생성자는 클래스 생성시 자바에서 자동으로 제공
- 매개변수를 받는 생성자를 선언시 기본생성자는 제공되지 않아 매개변수를 받지 않는 생성자가 필요할시
  새로 정의해서 추가해줘야한다.
- 생성자는 클래스와 이름이 같고 반환하는게 없기 때문에 void, int등 자료형을 쓰지 않는다
- 상속기능을 사용할 시 부모 생성자 먼저 동작하고 자식 생성자가 후에 동작한다

** this, this()에 대해 설명하시오
this는 클래스의 멤버함수를 가르키며
this를 사용할 시 메소드의 첫 줄에 위치시켜야한다
this를 사용하는 경우는 메소드에서 받는 매개변수의 이름을
의미있는 이름을 사용하다보면 멤버변수와 이름이 동일하게 될 때가 있는데
그때 멤버변수를 가르키기위해 사용한다.

**super, super()에 대하여 설명하시오
super는 부모 클래스를 가르키며
this와 마찬가지로 메소드 첫 줄에 위치시켜야한다.
주로 오버라이딩하는 경우에 부모클래스의 메소드를 호출하기 위해 사용된다

** overloading과 overriding에 대하여 설명하시오
overloading은 한 클래스 내에서 비슷한 기능을 하는 
동일한 이름의 메소드를 정의할 때 사용하며
선언시에는 반드시 받아오는 매개변수의 갯수를 다르게 하거나
자료형을 다르게 해줘야 한다.

overriding은 상속관계에서 사용되며 부모에게 물려받은 메소드의 기능이 마음에 안들어
자식 클래스에서 동일한 이름의 메소드를 기능을 다르게 하여 정의하는걸 뜻한다.

** 추상메소드와 추상클래스에 대하여 설명하시오
추상메소드는 상속관계에서만 사용 가능하며
공통된 이름의 속성에서
부모클래스에서는 구체화하기 힘든 메소드이고 미래에 자식클래스에서 구체화가 필요한
메소드일 시 부모클래스에서 미리 일반화를 시켜 정의하는 메소드를 뜻하며
추상메소드는 body가 없어야하며 모든 자식클래스에서 반드시 오버라이딩해야한다

추상클래스는 추상메소드를 갖는 클래스를 뜻하며 무조건 부모 클래스만 가능하다


정리------------------------------------------------------------------------------------------------
오버라이드한 메소드는
자식으로 선언하면 자식이 우선순위를 갖는다.

오버라이드 했을때 부모의 메소드를 호출하고 싶으면
super.동일한이름메소드(); 하면된다.

배열 만들때 부모 클래스로 배열 만든다.

자식에만 있는 메소드를 호출하려면
자식 클래스로 형변환 해줘야 호출 가능하다.
instanceof = 자료형이 뭔지 판별
double a;
a instanceof int == 거짓
((Graduate) i).paperReview(); 이런식으로 됨

상속관계에 있을때에 부모의 참조변수는 자식클래스의 객체를 생성할 수 있다.
이때 그 참조변수가 참조하고 있는 객체가 어떤 클래스의 자료형인지 판별하기 위해
instanceof 연산자를 이용

instanceof는 상속관계에 있을때만 사용 가능

오버라이딩 == 상속관계**
오버라이딩은 매개변수 개수와 자료형까지 일치되게 재정의해야함

abstract 
	일반화 해야하는 메소드중에 나중에 후손이 상세화 하는 메소드에 사용
	
추상클래스와 추상메소드
	미래에 만들어질 자식클래스들이 가져야 할 공통적인
	속성과 동작을 뽑아서 일반화(부모클래스)를 만들 때에
	어떠한 메소드가 반드시 자식클래스들에게는 필요한데
	이 시점(일반화)에는 메소드의 body를 구체화 할 수 없고
	자식들이 반드시 오버라이딩 하게끔 하기 위해
	메소드의 body를 쓰지 않고 메소드의 선언부만 적는다.
	이때 메소드의 body가 없음을 표시해야함
	그때 메소드 이름 왼쪽에 abstract 키워드를 붙임
	이것을 추상메소드라 함
	
	이와 같이 어떤 클래스가 추상메소드를 하나라도
	갖고 있으면 그 클래스 명 앞에 abstract 키워드를 붙여
	추상클래스로 만들어야한다.
	
	그러므로 어떠한 클래스가 추상클래스로 부터 상속받았다면
	반드시 추상클래스내에 있는 모든 추상메소드들을
	자신에게 맞도록 재정의(오버라이딩)해야 한다.
	public abstract class Shape{
		public abstract void calcRound();
		public abstract void calcArea();
	}
	이런식으로 사용	
	
	추상클래스는 객체로 생성 불가능
	Shape s = new Shape(); <== 불가능
	추상클래스는 상속받은 클래스가 추상메소드들을 모두 구체화 한 다음 객체 생성 가능